La scelta di chiamare gli stati con nomi simbolici ($S_i$) piuttosto che utilizzare nomi significativi è stata dettata dal fatto che nella nostra FSM uno stato non svolge singolarmente una funzione specifica; è invece l'unione di più stati che implementa una determinata funzionalità.
\paragraph{S9}
La macchina entra in questo stato quando il segnale R\_DONE e quello C\_DONE sono uguali a 1, quando cioè le iterazioni lungo le righe e le colonne sono terminate.
Il registro Address conterrà allora l'indirizzo del pixel immediatamente successivo all'ultimo pixel dell'immagine. A partire da questo indirzzo verrà salavata l'immagine equalizzata.\\
Inizializzo il contenuto del registro Address2 con il valore 2, indirizzo del primo pixel dell'immagine da equalizzare.\\
In questo stato la macchina ha già letto tutti i pixel dell'immagine e ne ha calcolato il valore massimo e minimo, questi ultimi sono disponibili all'interno dei registri Max e Min.\\
Posso allora calcolare, in maniera combinatoria, il valore di SHIFT\_LEVEL e caricarlo nell'omonimo registro.
Carico inoltre il valore del registro Address nel registro END\_IMG, quest'ultimo ci tornerà utile in seguito.\\
\paragraph{Ciclo S10, S11, S12, S13}
Ogni iterazione di questi 4 stati legge il valore di un pixel dell'immagine da equalizzare, lo processa e lo scrive in memoria all'indirizzo desiderato.
Per gestire correttamente gli indirizzi avrò bisogno di due registri:
\begin{itemize}
    \item Address: contiene l'indirzzo in cui scriverò l'immagine equalizzata.
    \item Address2: contiene l'indirizzo da cui leggerò l'immagine da equalizzare.
\end{itemize}
Questi due registri, sono stati inizializzati nello stato S9, e verranno aggiornati (aumentando l'indirizzo di 1) in parallelo alla fine di ogni iterazione del ciclo.
Occorrerà ciclare in questi 4 stati finchè tutti i pixel da equalizzare non saranno stati letti, processati e scritti in memoria. Per effettuare questo controllo, mi basta confrontare l'indirizzo contenuto in address2 con l'indirizzo finale dell'immagine, che ho precedentemente salvato in END\_IMG.\\
Quando questi due indirizzi coincidono, esco dal ciclo e vado nello stato S14.
Vediamo in dettaglio questi 4 stati:
\paragraph{S10}
La macchina chiede alla memoria il valore del pixel da equalizzare, fornendo come o\_address il valore contenuto nel registro address2.
\paragraph{S11}
Salvo il valore del pixel da equalizzare nel registro Old.
\paragraph{S12}
In questo stato è disponibile in uscita dal registro Old, il valore del pixel da processare, verrà eseguito lo shift di SHIFT\_LEVEL posizioni, e il confronto con 255. Ho così calcolato NEW\_PIXEL\_VALUE, che viene fornito in uscita attraverso o\_data e potrà essere scritto in memoria nel ciclo di clock successivo.
\paragraph{S13}
Scrivo in memoria all'indirizzo contenuto in o\_address, il valore del pixel equalizzato calcolato nello stato precedente.\\
Aumento poi di 1 sia l'indirizzo contenuto in address che quello contenuto in address2.
\paragraph{S14}
Ho terminato la computazione, alzo il segnale o\_done, e resto in questo stato finchè i\_start = 1, quando i\_start = 0, vado nello stato S0 e sono pronto per una nuova computazione.


La macchina a stati modellata, a livello concettuale, può essere divisa in due sezioni principali: la sezione di lettura (gestita dagli stati compresi tra S\textsubscript{0} e S\textsubscript{8}) e la sezione di scrittura( gestita dagli stati compresi tra S\textsubscript{9} e S\textsubscript{14}).

S\textsubscript{0} è lo stato di Reset della macchina e quest'ultima rimane in questo stato fino a quando non riceve il segnale 'i\_start' alto, che indica che può iniziare la conversione dell'immagine.

Gli stati S\textsubscript{1}, S\textsubscript{2}, S\textsubscript{3}, S\textsubscript{4}, S\textsubscript{5} si occupano di inizializzare correttamente i vari registri dei moduli precedentemente illustrati, tra cui: c\_max register, r\_max register, max register e min register.
In caso di dimensioni nulle dell'immagine (segnalate dal row\_counter module o dal column\_counter module rispettivamente tramite i segnali row\_zero e column\_zero), la macchina si sposta nello stato S\textsubscript{14} che viene descritto più nel dettaglio in seguito, altrimenti si sposta nello stato S\textsubscript{6}.

Gli stati S\textsubscript{6}, S\textsubscript{7}, S\textsubscript{8} si occupano di effettuare la lettura corretta dell'immagine e di individuare i valori di massima e minima intensità assunti dai pixel. Più precisamente, gli stati S\textsubscript{6} e S\textsubscript{8} gestiscono il nested loop descritto nella sezione \textbf{Row \& Column counter}, infatti i segnali c\_done e r\_done, una volta posti a '1', segnalano rispettivamente la fine di una riga e la fine dell'immagine.

